<p>给定两个整数数组，<code>preorder</code>&nbsp;和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>

<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg" style="height: 265px; width: 304px;" /></p>

<pre>
<strong>输入：</strong>preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
<strong>输出：</strong>[1,2,3,4,5,6,7]
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> preorder = [1], postorder = [1]
<strong>输出:</strong> [1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= preorder.length &lt;= 30</code></li> 
 <li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li> 
 <li><code>preorder</code>&nbsp;中所有值都 <strong>不同</strong></li> 
 <li><code>postorder.length == preorder.length</code></li> 
 <li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li> 
 <li><code>postorder</code>&nbsp;中所有值都 <strong>不同</strong></li> 
 <li>保证 <code>preorder</code>&nbsp;和 <code>postorder</code>&nbsp;是同一棵二叉树的前序遍历和后序遍历</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>树 | 数组 | 哈希表 | 分治 | 二叉树</details><br>

<div>👍 318, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.gitee.io/article/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.github.io/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：[数据结构精品课](https://aep.h5.xeknow.com/s/1XJHEO) 和 [递归算法专题课](https://aep.xet.tech/s/3YGcq3) 限时附赠网站会员！[第 21 期打卡挑战](https://opedk.xet.tech/s/4ptSo2) 最后一天报名！**



<p><strong><a href="https://labuladong.gitee.io/article/slug.html?slug=construct-binary-tree-from-preorder-and-postorder-traversal" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

## 基本思路

做这道题之前，建议你先看一下 [东哥手把手帮你刷通二叉树|第二期](https://labuladong.github.io/article/fname.html?fname=二叉树系列2)，做一下 [105. 从前序与中序遍历序列构造二叉树（中等）](/problems/construct-binary-tree-from-preorder-and-inorder-traversal) 和 [106. 从中序与后序遍历序列构造二叉树（中等）](/problems/construct-binary-tree-from-inorder-and-postorder-traversal) 这两道题。

这道题让用后序遍历和前序遍历结果还原二叉树，和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。题目也说了，如果有多种结果，你可以返回任意一种。

为什么呢？我们说过，构建二叉树的套路很简单，先找到根节点，然后找到并递归构造左右子树即可。

前两道题，可以通过前序或者后序遍历结果找到根节点，然后根据中序遍历结果确定左右子树。

这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点。

举个例子，下面这两棵树结构不同，但是它们的前序遍历和后序遍历结果是相同的：

![](https://labuladong.github.io/pictures/二叉树系列2/7.png)

不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：

**1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值**。

**2、然后把前序遍历结果的第二个元素作为左子树的根节点的值**。

**3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可**。

![](https://labuladong.github.io/pictures/二叉树系列2/8.jpeg)

**详细题解：[东哥带你刷二叉树（构造篇）](https://labuladong.github.io/article/fname.html?fname=二叉树系列2)**

**标签：[二叉树](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2121994699837177859)**

## 解法代码

提示：🟢 标记的是我写的解法代码，🤖 标记的是 chatGPT 翻译的多语言解法代码。如有错误，可以 [点这里](https://github.com/labuladong/fucking-algorithm/issues/1113) 反馈和修正。

<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution {
    // 存储 postorder 中值到索引的映射
    unordered_map<int, int> valToIndex;

public:
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        for (int i = 0; i < postorder.size(); i++) {
            valToIndex[postorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                     postorder, 0, postorder.size() - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return nullptr;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex[leftRootVal];
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode* root = new TreeNode(rootVal);

        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root->left = build(preorder, preStart + 1, preStart + leftSize,
                           postorder, postStart, index);
        root->right = build(preorder, preStart + leftSize + 1, preEnd,
                            postorder, index + 1, postEnd - 1);

        return root;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
# 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution:
    # 存储 postorder 中值到索引的映射
    valToIndex = {}

    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        for i in range(len(postorder)):
            self.valToIndex[postorder[i]] = i
        return self.build(preorder, 0, len(preorder) - 1,
                           postorder, 0, len(postorder) - 1)

    # 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    # 构建二叉树，并返回根节点。
    def build(self, preorder, preStart, preEnd, postorder, postStart, postEnd):
        if preStart > preEnd:
            return None
        if preStart == preEnd:
            return TreeNode(preorder[preStart])

        # root 节点对应的值就是前序遍历数组的第一个元素
        rootVal = preorder[preStart]
        # root.left 的值是前序遍历第二个元素
        # 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        # 确定 preorder 和 postorder 中左右子树的元素区间
        leftRootVal = preorder[preStart + 1]
        # leftRootVal 在后序遍历数组中的索引
        index = self.valToIndex[leftRootVal]
        # 左子树的元素个数
        leftSize = index - postStart + 1

        # 先构造出当前根节点
        root = TreeNode(rootVal)
        # 递归构造左右子树
        # 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root.left = self.build(preorder, preStart + 1, preStart + leftSize,
                               postorder, postStart, index)
        root.right = self.build(preorder, preStart + leftSize + 1, preEnd,
                                postorder, index + 1, postEnd - 1)

        return root
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    // 存储 postorder 中值到索引的映射
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for (int i = 0; i < postorder.length; i++) {
            valToIndex.put(postorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    postorder, 0, postorder.length - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return null;
        }
        if (preStart == preEnd) {
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex.get(leftRootVal);
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode root = new TreeNode(rootVal);/**<extend up -200>![](https://labuladong.github.io/pictures/二叉树系列2/8.jpeg) */
        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                postorder, postStart, index);
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                postorder, index + 1, postEnd - 1);

        return root;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

// Definition for a binary tree node.
// type TreeNode struct {
//     Val int
//     Left *TreeNode
//     Right *TreeNode
// }

func constructFromPrePost(preorder []int, postorder []int) *TreeNode {
    // 存储 postorder 中值到索引的映射
    valToIndex := make(map[int]int)
    for i, v := range postorder {
        valToIndex[v] = i
    }
    return build(preorder, 0, len(preorder)-1, postorder, 0, len(postorder)-1, valToIndex)
}

// 根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd] 构建二叉树，并返回根节点。
func build(preorder []int, preStart int, preEnd int, postorder []int, postStart int, postEnd int, valToIndex map[int]int) *TreeNode {
    if preStart > preEnd {
        return nil
    }
    if preStart == preEnd {
        return &TreeNode{Val: preorder[preStart]}
    }

    // root 节点对应的值就是前序遍历数组的第一个元素
    rootVal := preorder[preStart]
    // root.left 的值是前序遍历第二个元素
    // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
    // 确定 preorder 和 postorder 中左右子树的元素区间
    leftRootVal := preorder[preStart+1]
    // leftRootVal 在后序遍历数组中的索引
    index := valToIndex[leftRootVal]
    // 左子树的元素个数
    leftSize := index - postStart + 1

    // 先构造出当前根节点
    root := &TreeNode{Val: rootVal}
    // 递归构造左右子树
    // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
    root.Left = build(preorder, preStart+1, preStart+leftSize, postorder, postStart, index, valToIndex)
    root.Right = build(preorder, preStart+leftSize+1, preEnd, postorder, index+1, postEnd-1, valToIndex)

    return root
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function(preorder, postorder) {
    // 存储 postorder 中值到索引的映射
    const valToIndex = new Map();
    for (let i = 0; i < postorder.length; i++) {
        valToIndex.set(postorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1,
                postorder, 0, postorder.length - 1, valToIndex);
};

/**
 * @param {number[]} preorder
 * @param {number} preStart
 * @param {number} preEnd
 * @param {number[]} postorder
 * @param {number} postStart
 * @param {number} postEnd
 * @param {Map} valToIndex
 * @return {TreeNode}
 */
function build(preorder, preStart, preEnd, postorder, postStart, postEnd, valToIndex) {
    if (preStart > preEnd) {
        return null;
    }
    if (preStart === preEnd) {
        return new TreeNode(preorder[preStart]);
    }

    // root 节点对应的值就是前序遍历数组的第一个元素
    const rootVal = preorder[preStart];
    // root.left 的值是前序遍历第二个元素
    // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
    // 确定 preorder 和 postorder 中左右子树的元素区间
    const leftRootVal = preorder[preStart + 1];
    // leftRootVal 在后序遍历数组中的索引
    const index = valToIndex.get(leftRootVal);
    // 左子树的元素个数
    const leftSize = index - postStart + 1;

    // 先构造出当前根节点
    const root = new TreeNode(rootVal);

    // 递归构造左右子树
    // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
    root.left = build(preorder, preStart + 1, preStart + leftSize,
            postorder, postStart, index, valToIndex);
    root.right = build(preorder, preStart + leftSize + 1, preEnd,
            postorder, index + 1, postEnd - 1, valToIndex);

    return root;
}
```

</div></div>
</div></div>

<details open><summary><strong>🍭🍭 算法可视化 🍭🍭</strong></summary><div id="data_construct-binary-tree-from-preorder-and-postorder-traversal" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_construct-binary-tree-from-preorder-and-postorder-traversal"></div></div>
</details><hr /><br />

**类似题目**：
  - [105. 从前序与中序遍历序列构造二叉树 🟠](/problems/construct-binary-tree-from-preorder-and-inorder-traversal)
  - [106. 从中序与后序遍历序列构造二叉树 🟠](/problems/construct-binary-tree-from-inorder-and-postorder-traversal)
  - [654. 最大二叉树 🟠](/problems/maximum-binary-tree)
  - [剑指 Offer 07. 重建二叉树 🟠](/problems/zhong-jian-er-cha-shu-lcof)

</details>
</div>



